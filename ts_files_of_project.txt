import { useToast, toast } from "@/hooks/use-toast";

export { useToast, toast };
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
import { initializeApp } from 'firebase/app';
import { getDatabase, ref, set, get, update, onValue, off, push, child, remove } from 'firebase/database';
import { v4 as uuidv4 } from 'uuid';

// Firebase configuration
// Replace with your own Firebase configuration from the Firebase console
const firebaseConfig = {
    apiKey: "AIzaSyAQdLCw8JPfRfZJdHgjsM9CFArbHWL-SCQ",
    authDomain: "virtual-card-playground.firebaseapp.com",
    databaseURL: "https://virtual-card-playground-default-rtdb.firebaseio.com",
    projectId: "virtual-card-playground",
    storageBucket: "virtual-card-playground.firebasestorage.app",
    messagingSenderId: "1095507757324",
    appId: "1:1095507757324:web:e03d82d3aa60188d926129"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const database = getDatabase(app);

// Types for game data
import { CardType } from '@/utils/cardUtils';
import { Player } from '@/components/GameTable';
import { Rank, Suit } from '@/components/Card';

// Game session interface
export interface GameSession {
    roomId: string;
    players: Player[];
    deckCards: CardType[];
    tableCards: Array<CardType & { x: number, y: number }>;
    cardGroups?: Array<{
        id: string;
        cards: Array<{
            id: string;
            suit: Suit;
            rank: Rank;
            faceUp: boolean;
        }>;
        x: number;
        y: number;
        mode: 'fan' | 'stack';
    }>;
    lastUpdate: number;
}

// Firebase utility functions
export const firebaseService = {
    // Create a new game room
    createRoom: async (creatorName: string): Promise<[string, string]> => {
        // Generate a unique room ID (6 characters, uppercase)
        const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
        const playerId = uuidv4();

        // Create initial game state with the creator as the first player
        const newGameState: GameSession = {
            roomId,
            players: [{
                id: playerId,
                name: creatorName,
                cards: [],
                position: 0
            }],
            deckCards: [], // We'll initialize the deck after creating the room
            tableCards: [],
            lastUpdate: Date.now()
        };

        // Save to Firebase
        const roomRef = ref(database, `rooms/${roomId}`);
        await set(roomRef, newGameState);

        return [roomId, playerId];
    },

    // Join an existing room
    joinRoom: async (roomId: string, playerName: string): Promise<[string, string, boolean]> => {
        try {
            // Check if room exists
            const roomRef = ref(database, `rooms/${roomId}`);
            const snapshot = await get(roomRef);

            if (!snapshot.exists()) {
                return ['', '', false];
            }

            const gameState = snapshot.val() as GameSession;
            const playerId = uuidv4();

            // Ensure players array exists
            const players = gameState.players || [];

            // Add player to the room
            const position = players.length;
            players.push({
                id: playerId,
                name: playerName,
                cards: [],
                position
            });

            // Update the room data with the new player
            await update(roomRef, {
                players: players,
                lastUpdate: Date.now()
            });

            return [roomId, playerId, true];
        } catch (error) {
            console.error("Error joining room:", error);
            return ['', '', false];
        }
    },

    // Get current game state
    getGameState: async (roomId: string): Promise<GameSession | null> => {
        try {
            const roomRef = ref(database, `rooms/${roomId}`);
            const snapshot = await get(roomRef);

            if (!snapshot.exists()) {
                return null;
            }

            const data = snapshot.val();

            // Ensure all required properties exist
            const safeGameState: GameSession = {
                roomId: data.roomId || roomId,
                players: data.players || [],
                deckCards: data.deckCards || [],
                tableCards: data.tableCards || [],
                cardGroups: data.cardGroups || [], // Incluir cardGroups
                lastUpdate: data.lastUpdate || Date.now()
            };

            return safeGameState;
        } catch (error) {
            console.error("Error getting game state:", error);
            return null;
        }
    },

    // Update game state with a transaction
    updateGameState: async (roomId: string, updateFunction: (state: GameSession) => GameSession): Promise<boolean> => {
        try {
            // Get current state
            const roomRef = ref(database, `rooms/${roomId}`);
            const snapshot = await get(roomRef);

            if (!snapshot.exists()) {
                return false;
            }

            // Apply the update function to the current state
            const currentState = snapshot.val() as GameSession;

            // Ensure all required properties exist before updating
            const safeState: GameSession = {
                roomId: currentState.roomId || roomId,
                players: currentState.players || [],
                deckCards: currentState.deckCards || [],
                tableCards: currentState.tableCards || [],
                cardGroups: currentState.cardGroups || [], // Incluir cardGroups
                lastUpdate: currentState.lastUpdate || Date.now()
            };

            // Apply the update function to get new state
            const newState = updateFunction(safeState);

            // Update the timestamp
            newState.lastUpdate = Date.now();

            // Ensure all properties still exist after the update
            const safeNewState: GameSession = {
                roomId: newState.roomId || roomId,
                players: newState.players || [],
                deckCards: newState.deckCards || [],
                tableCards: newState.tableCards || [],
                cardGroups: newState.cardGroups || [], // Incluir cardGroups
                lastUpdate: newState.lastUpdate
            };

            // Save the new state
            await set(roomRef, safeNewState);

            return true;
        } catch (error) {
            console.error("Error updating game state:", error);
            return false;
        }
    },

    // Subscribe to real-time updates for a room
    subscribeToRoom: (roomId: string, callback: (gameState: GameSession) => void) => {
        const roomRef = ref(database, `rooms/${roomId}`);

        // Set up real-time listener
        onValue(roomRef, (snapshot) => {
            if (snapshot.exists()) {
                const data = snapshot.val();

                // Ensure all required properties exist
                const safeGameState: GameSession = {
                    roomId: data.roomId || roomId,
                    players: data.players || [],
                    deckCards: data.deckCards || [],
                    tableCards: data.tableCards || [],
                    cardGroups: data.cardGroups || [], // Incluir cardGroups
                    lastUpdate: data.lastUpdate || Date.now()
                };

                callback(safeGameState);
            }
        });

        // Return unsubscribe function
        return () => off(roomRef);
    },

    // Leave a room
    leaveRoom: async (roomId: string, playerId: string): Promise<boolean> => {
        try {
            const roomRef = ref(database, `rooms/${roomId}`);
            const snapshot = await get(roomRef);

            if (!snapshot.exists()) {
                return false;
            }

            const gameState = snapshot.val() as GameSession;

            // Ensure players array exists
            const players = gameState.players || [];

            // Filter out the leaving player
            const updatedPlayers = players.filter(player => player.id !== playerId);

            // If no players left, delete the room
            if (updatedPlayers.length === 0) {
                await remove(roomRef);
                return true;
            }

            // Update the player positions if needed
            updatedPlayers.forEach((player, index) => {
                player.position = index;
            });

            // Update the game state
            await update(roomRef, {
                players: updatedPlayers,
                lastUpdate: Date.now()
            });

            return true;
        } catch (error) {
            console.error("Error leaving room:", error);
            return false;
        }
    }
};

export default firebaseService;import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

import { Suit, Rank } from '@/components/Card';
import { v4 as uuidv4 } from 'uuid';

export interface CardType {
  id: string;
  suit: Suit;
  rank: Rank;
  faceUp: boolean;
}

export const SUITS: Suit[] = ['hearts', 'diamonds', 'clubs', 'spades'];
export const RANKS: Rank[] = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

export const createDeck = (): CardType[] => {
  const deck: CardType[] = [];
  
  for (const suit of SUITS) {
    for (const rank of RANKS) {
      deck.push({
        id: uuidv4(),
        suit,
        rank,
        faceUp: false
      });
    }
  }
  
  return deck;
};

export const shuffleDeck = (deck: CardType[]): CardType[] => {
  const newDeck = [...deck];
  
  for (let i = newDeck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
  }
  
  return newDeck;
};

export const dealCard = (deck: CardType[]): { card: CardType | null, newDeck: CardType[] } => {
  if (deck.length === 0) {
    return { card: null, newDeck: [] };
  }
  
  const newDeck = [...deck];
  const card = newDeck.pop()!;
  
  return { card, newDeck };
};

export const removeCardsByRank = (deck: CardType[], ranks: Rank[]): CardType[] => {
  return deck.filter(card => !ranks.includes(card.rank));
};

export const removeCardsBySuit = (deck: CardType[], suits: Suit[]): CardType[] => {
  return deck.filter(card => !suits.includes(card.suit));
};

export const removeSpecificCards = (deck: CardType[], cardsToRemove: { suit: Suit, rank: Rank }[]): CardType[] => {
  return deck.filter(card => {
    return !cardsToRemove.some(c => c.suit === card.suit && c.rank === card.rank);
  });
};

export const moveCard = (
  source: CardType[],
  destination: CardType[],
  cardIndex: number,
  faceUp: boolean = false
): { newSource: CardType[], newDestination: CardType[] } => {
  if (cardIndex < 0 || cardIndex >= source.length) {
    return { newSource: source, newDestination: destination };
  }
  
  const newSource = [...source];
  const newDestination = [...destination];
  
  const [card] = newSource.splice(cardIndex, 1);
  card.faceUp = faceUp;
  
  newDestination.push(card);
  
  return { newSource, newDestination };
};

export const reorderCards = (
  cards: CardType[],
  startIndex: number,
  endIndex: number
): CardType[] => {
  const result = [...cards];
  const [removed] = result.splice(startIndex, 1);
  result.splice(endIndex, 0, removed);
  
  return result;
};

import type { Config } from "tailwindcss";

export default {
	darkMode: ["class"],
	content: [
		"./pages/**/*.{ts,tsx}",
		"./components/**/*.{ts,tsx}",
		"./app/**/*.{ts,tsx}",
		"./src/**/*.{ts,tsx}",
	],
	prefix: "",
	theme: {
		container: {
			center: true,
			padding: '2rem',
			screens: {
				'2xl': '1400px'
			}
		},
		extend: {
			colors: {
				border: 'hsl(var(--border))',
				input: 'hsl(var(--input))',
				ring: 'hsl(var(--ring))',
				background: 'hsl(var(--background))',
				foreground: 'hsl(var(--foreground))',
				primary: {
					DEFAULT: 'hsl(var(--primary))',
					foreground: 'hsl(var(--primary-foreground))'
				},
				secondary: {
					DEFAULT: 'hsl(var(--secondary))',
					foreground: 'hsl(var(--secondary-foreground))'
				},
				destructive: {
					DEFAULT: 'hsl(var(--destructive))',
					foreground: 'hsl(var(--destructive-foreground))'
				},
				muted: {
					DEFAULT: 'hsl(var(--muted))',
					foreground: 'hsl(var(--muted-foreground))'
				},
				accent: {
					DEFAULT: 'hsl(var(--accent))',
					foreground: 'hsl(var(--accent-foreground))'
				},
				popover: {
					DEFAULT: 'hsl(var(--popover))',
					foreground: 'hsl(var(--popover-foreground))'
				},
				card: {
					DEFAULT: 'hsl(var(--card))',
					foreground: 'hsl(var(--card-foreground))'
				},
				table: {
					DEFAULT: 'hsl(120, 30%, 25%)',
					dark: 'hsl(120, 30%, 20%)'
				}
			},
			borderRadius: {
				lg: 'var(--radius)',
				md: 'calc(var(--radius) - 2px)',
				sm: 'calc(var(--radius) - 4px)'
			},
			keyframes: {
				'accordion-down': {
					from: { height: '0', opacity: '0' },
					to: { height: 'var(--radix-accordion-content-height)', opacity: '1' }
				},
				'accordion-up': {
					from: { height: 'var(--radix-accordion-content-height)', opacity: '1' },
					to: { height: '0', opacity: '0' }
				},
				'fade-in': {
					'0%': { opacity: '0', transform: 'translateY(10px)' },
					'100%': { opacity: '1', transform: 'translateY(0)' }
				},
				'fade-out': {
					'0%': { opacity: '1', transform: 'translateY(0)' },
					'100%': { opacity: '0', transform: 'translateY(10px)' }
				},
				'scale-in': {
					'0%': { transform: 'scale(0.95)', opacity: '0' },
					'100%': { transform: 'scale(1)', opacity: '1' }
				},
				'slide-in': {
					'0%': { transform: 'translateY(100%)' },
					'100%': { transform: 'translateY(0)' }
				},
				'slide-down': {
					'0%': { transform: 'translateY(-100%)' },
					'100%': { transform: 'translateY(0)' }
				},
				'card-flip': {
					'0%': { transform: 'rotateY(0deg)' },
					'100%': { transform: 'rotateY(180deg)' }
				},
				'card-shuffle': {
					'0%': { transform: 'translateX(0) rotate(0)' },
					'25%': { transform: 'translateX(5px) rotate(5deg)' },
					'50%': { transform: 'translateX(-5px) rotate(-5deg)' },
					'75%': { transform: 'translateX(5px) rotate(5deg)' },
					'100%': { transform: 'translateX(0) rotate(0)' }
				},
				float: {
					'0%': { transform: 'translateY(0)' },
					'50%': { transform: 'translateY(-5px)' },
					'100%': { transform: 'translateY(0)' }
				}
			},
			animation: {
				'accordion-down': 'accordion-down 0.2s ease-out',
				'accordion-up': 'accordion-up 0.2s ease-out',
				'fade-in': 'fade-in 0.3s ease-out',
				'fade-out': 'fade-out 0.3s ease-out',
				'scale-in': 'scale-in 0.2s ease-out',
				'slide-in': 'slide-in 0.4s ease-out',
				'slide-down': 'slide-down 0.4s ease-out',
				'card-flip': 'card-flip 0.4s ease-out forwards',
				'card-shuffle': 'card-shuffle 0.5s ease-in-out',
				'float': 'float 3s ease-in-out infinite'
			}
		}
	},
	plugins: [require("tailwindcss-animate")],
} satisfies Config;
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
  },
  plugins: [
    react(),
    mode === 'development' &&
    componentTagger(),
  ].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
